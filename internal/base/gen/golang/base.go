//Copyright 2013 Vastech SA (PTY) LTD
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

package golang

import (
	"bytes"
	"go/format"
	"path"
	"text/template"

	"github.com/maxcalandrelli/gocc/internal/config"

	"github.com/maxcalandrelli/gocc/internal/io"
)

type data struct {
	MyName  string
	Pkg     string
	Outdir  string
	Subpath string
	Config  config.Config
}

func Gen(pkg, outdir, subpath string, cfg config.Config) {
	baseName := path.Base(outdir)
	d := data{
		MyName:  baseName,
		Pkg:     pkg,
		Outdir:  outdir,
		Subpath: subpath,
		Config:  cfg,
	}
	if !cfg.NoLexer() {
		genBase(d)
		genMain(d)
	}
	genIface(d)
}

func genBase(d data) {
	basePath := path.Join(d.Outdir, d.MyName+".go")
	tmpl, err := template.New(d.MyName).Parse(baseSrc[1:])
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, d)
	// Use go/format to indent the idMap literal correctly.
	source, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	io.WriteFile(basePath, source)
}

func genMain(d data) {
	basePath := path.Join(d.Outdir, "main", "main.go")
	tmpl, err := template.New(d.MyName).Parse(mainSrc[1:])
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, d)
	// Use go/format to indent the idMap literal correctly.
	source, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	io.WriteFile(basePath, source)
}

func genIface(d data) {
	basePath := path.Join(d.Outdir, "iface", "iface.go")
	tmpl, err := template.New(d.MyName).Parse(ifaceSrc[1:])
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, d)
	// Use go/format to indent the idMap literal correctly.
	source, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	io.WriteFile(basePath, source)
}

const baseSrc string = `
// Code generated by gocc; DO NOT EDIT.

package {{.MyName}}

import (
  "io"

  "{{.Pkg}}/{{.Subpath}}/token"
  "{{.Pkg}}/{{.Subpath}}/lexer"
  "{{.Pkg}}/{{.Subpath}}/parser"
  "{{.Pkg}}/{{.Subpath}}/io/stream"
  "{{.Pkg}}/iface"
)

type (
  Token = token.Token
  Lexer = lexer.Lexer
  Parser = parser.Parser
	TokenStream = iface.TokenStream
  WindowReader = stream.WindowReader
  Scanner = iface.Scanner
)


func ParseFile(fpath string) (interface{}, error, int) {
  if lexer, err := NewLexerFile(fpath); err == nil {
    return NewParser().Parse(lexer)
  } else {
    return nil, err, 0
  }
}

func ParseText(text string) (interface{}, error, int) {
  return NewParser().Parse(NewLexerBytes([]byte(text)))
}

func NewLexerBytes(src []byte) *lexer.Lexer {
  return lexer.NewLexerBytes(src)
}

func NewLexerString(src string) *lexer.Lexer {
  return lexer.NewLexerBytes([]byte(src))
}

func NewLexerFile(fpath string) (*lexer.Lexer, error) {
  return lexer.NewLexerFile(fpath)
}

func NewParser() *parser.Parser {
  return parser.NewParser()
}


func NewWindowReaderFromBytes(src []byte) WindowReader {
	return stream.NewWindowReaderFromBytes(src)
}

func NewWindowReader(rdr io.Reader) WindowReader {
	return stream.NewWindowReader(rdr)
}

func NewLimitedWindowReader(rdr io.Reader, sizeMin, sizeMax int) WindowReader {
	return stream.NewLimitedWindowReader(rdr, sizeMin, sizeMax)
}

`

const mainSrc string = `
package main

import (
  "flag"
  "fmt"
  "os"
  "strings"

  {{.MyName}} "{{.Pkg}}"
)

func showResult (r interface{}, e error, l int) {
  if e != nil {
    fmt.Fprintf(os.Stderr, "parsing returned the following error: %s\n", e.Error())
  } else {
    fmt.Printf("r=%#v, %d bytes\n", r, l)
  }
}

var (
  File string
  Text string
	Longest bool
)

func parse (longest bool, lex *{{.MyName}}.Lexer) (res interface{}, err error, ptl int) {
  if longest {
    return {{.MyName}}.NewParser().ParseLongestPrefix(lex)
  } else {
    return {{.MyName}}.NewParser().Parse(lex)
  }
  return
}

func main () {
  flag.StringVar(&File, "file", "", "parse also text in file")
  flag.StringVar(&Text, "text", "", "parse also text given with flag")
	flag.BoolVar(&Longest, "longest", false, "parse longest possible part")
  flag.Parse()
  if Text > "" {
    showResult(parse(Longest, {{.MyName}}.NewLexerString(Text)))
  }
  if File > "" {
    l, e := {{.MyName}}.NewLexerFile(File)
    if e != nil { panic(e) }
    showResult(parse(Longest, l))
  }
  if str := strings.Join(flag.Args(), " "); str > "" {
    showResult(parse(Longest, {{.MyName}}.NewLexerString(str)))
  }
}

`

const ifaceSrc string = `
// Code generated by gocc; DO NOT EDIT.

package iface

import (
  "io"
  "{{.Pkg}}/{{.Subpath}}/token"
)

type (
  Scanner interface {
  	Scan() (tok *token.Token)
  }

  StreamScanner interface {
    GetStream() TokenStream
  }

  CheckPoint interface {
    DistanceFrom(CheckPoint) int
  }

  CheckPointable interface {
  	GetCheckPoint() CheckPoint
    GotoCheckPoint(CheckPoint)
  }

  TokenStream interface {
    io.Reader
  	io.RuneScanner
  	io.Seeker
  }
)


`
