//Copyright 2013 Vastech SA (PTY) LTD
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

package golang

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"regexp"
	"text/template"

	"github.com/maxcalandrelli/gocc/internal/config"

	"github.com/maxcalandrelli/gocc/internal/ast"
	"github.com/maxcalandrelli/gocc/internal/io"
	"github.com/maxcalandrelli/gocc/internal/parser/lr1/items"
	"github.com/maxcalandrelli/gocc/internal/parser/symbols"
	"github.com/maxcalandrelli/gocc/internal/token"
)

func GenProductionsTable(pkg, outDir, header string, prods ast.SyntaxProdList, symbols *symbols.Symbols,
	itemsets *items.ItemSets, tokMap *token.TokenMap, internal string, cfg config.Config) {

	fname := path.Join(outDir, internal, "parser", "productionstable.go")
	tmpl, err := template.New("parser productions table").Parse(prodsTabSrc[1:])
	if err != nil {
		panic(err)
	}
	wr := new(bytes.Buffer)
	pTab := getProdsTab(header, prods, symbols, itemsets, tokMap)
	pTab.Pkg = pkg
	pTab.Outdir = outDir
	pTab.InternalDir = internal
	pTab.Config = cfg

	if err := tmpl.Execute(wr, pTab); err != nil {
		panic(err)
	}

	source, err := format.Source(wr.Bytes())
	if err != nil {
		panic(err)
	}
	io.WriteFile(fname, source)
}

func getProdsTab(header string, prods ast.SyntaxProdList, symbols *symbols.Symbols,
	itemsets *items.ItemSets, tokMap *token.TokenMap) *prodsTabData {

	data := &prodsTabData{
		Header:  header,
		ProdTab: make([]prodTabEntry, len(prods)),
	}
	for i, prod := range prods {
		data.ProdTab[i].String = fmt.Sprintf("`%s`", prod.String())
		data.ProdTab[i].Id = prod.Id.SymbolString()
		data.ProdTab[i].NTType = symbols.NTType(prod.Id.SymbolString())
		isEmpty := prod.Body.Empty()
		if isEmpty {
			data.ProdTab[i].NumSymbols = 0
		} else {
			data.ProdTab[i].NumSymbols = len(prod.Body.Symbols)
			for _, s := range prod.Body.Symbols {
				switch s.(type) {
				case ast.SyntaxContextDependentTokId, ast.SyntaxSubParser:
					data.ProdTab[i].NumSymbols++
				}
			}
		}
		switch {
		case len(prod.Body.SDT) > 0:
			data.ProdTab[i].ReduceFunc = fmt.Sprintf("return %s", replaceSDTvars(prod.Body.SDT))
		case isEmpty:
			// Empty production with no semantic action.
			data.ProdTab[i].ReduceFunc = "return nil, nil"
		default:
			data.ProdTab[i].ReduceFunc = "return X[0], nil"
		}
	}

	return data
}

var (
	sdtReplacerBase   = regexp.MustCompile("\\$([0-9]+)")
	sdtReplacerGetStr = regexp.MustCompile("\\$s([0-9]+)")
	sdtReplacerGetUnq = regexp.MustCompile("\\$u([0-9]+)")
)

func replaceSDTvars(sdt string) string {
	ret := sdt
	ret = sdtReplacerBase.ReplaceAllString(ret, fmt.Sprintf("X[${1}]"))
	ret = sdtReplacerGetStr.ReplaceAllString(ret, fmt.Sprintf("getString(X[${1}])"))
	ret = sdtReplacerGetUnq.ReplaceAllString(ret, fmt.Sprintf("getUnquotedString(X[${1}])"))
	// TODO: reorder this as: stringize, unquote, unescape, uppercase, lowercase, etc.
	return ret
}

type prodsTabData struct {
	Header      string
	ProdTab     []prodTabEntry
	Pkg         string
	Outdir      string
	InternalDir string
	Config      config.Config
}

type prodTabEntry struct {
	String      string
	Id          string
	NTType      int
	NumSymbols  int
	ReduceFunc  string
	TokenImport string
}

const prodsTabSrc = `
// Code generated by gocc; DO NOT EDIT.

package parser

{{.Header}}


import (
  "fmt"
  "{{.Config.Package}}/{{.InternalDir}}/token"
)

func getString(X Attrib) string {
  switch X.(type) {
    case *token.Token: return string(X.(*token.Token).Lit)
    case string: return X.(string)
  }
  return fmt.Sprintf("%q", X)
}

func getUnquotedString(X Attrib) string {
  ret := getString(X)
  if len(ret)>1 {
    if (ret[0] == '\'' || ret[0] == '"') && ret[len(ret)-1]==ret[0] {
      ret = ret[1:len(ret)-1]
    }
  }
  return ret
}

type (
	//TODO: change type and variable names to be consistent with other tables
	ProdTab      [numProductions]ProdTabEntry
	ProdTabEntry struct {
		String     string
		Id         string
		NTType     int
		Index      int
		NumSymbols int
		ReduceFunc func(interface{}, []Attrib) (Attrib, error)
	}
	Attrib interface {
	}
)

var productionsTable = ProdTab{
	{{- range $i, $entry := .ProdTab }}
	ProdTabEntry{
		String: {{$entry.String}},
		Id:         "{{$entry.Id}}",
		NTType:     {{$entry.NTType}},
		Index:      {{$i}},
		NumSymbols: {{$entry.NumSymbols}},
		ReduceFunc: func(Context interface{}, X []Attrib) (Attrib, error) {
			{{$entry.ReduceFunc}}
		},
	},
	{{- end }}
}
`
